---
title: "agreement-probing-stats"
output:
  pdf_document: 
    latex_engine: xelatex
    keep_tex: yes
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE)
```

```{r, message=FALSE, warning=FALSE}
library(tidyr)
library(dplyr)
library(stringr)
library(readr)
library(readxl)
library(reshape2)

library(ggplot2)
library(viridis)
library(grid)
library(gtable)
library(lemon)

library(lme4)
library(lmerTest)
library(pbkrtest)
library(nlme)

library("broom.mixed")

library(extrafont)
```

```{r, echo=FALSE, include=FALSE}
citation("lmerTest")
```

```{r, echo=FALSE, include=FALSE}
citation("pbkrtest")
```


## Loading datasets

```{r}
gpt <- read_csv("gpt.csv")
gpt_comp <- read_csv("../perplexity/ruGPT-35-13B_score_second.csv")
rubert <- read_delim("rubert_all.csv", delim=",", locale = locale(decimal_mark = ","))
rubert_comp <- read_csv("../perplexity/rubert_compatibility_score.csv")
humans <- read_excel("./data number attr.xlsx")

```
We add columns encoding grammaticality kind of the sentence: `gram`(matical), (ungrammatical with) `distr`(actor), `ungram`(matical)

```{r}
rubert_comp
```


```{r}

add_grammaticality_column <- function(df){
  df %>% mutate(
    kind=as.factor(case_when(
      N1 == Pred ~ "gram",
      (N1 != Pred) & (N2 == Pred) ~ "distr",
      TRUE ~ "ungram"
    )),
    is_correct = N1 == Pred,
    is_distractor = N2 == Pred,
    distr_like_pl = N2 == "P" | (N2 == "S" & Group==2),
    .after=Pred
  )
}

convert_to_factor_columns <- function(
  df, to_factor_columns = c("N1", "N2", "Pred", "Code")
){
  df %>%
    mutate(across(all_of(to_factor_columns), as.factor))
}

```



```{r}
rubert_comp %>%
  add_grammaticality_column(.) %>%
  convert_to_factor_columns(.) ->
  rubert_comp

rubert_comp %>% 
  mutate(is_distr_different = N2 != N1, .after = Pred) ->
  rubert_comp
  
gpt_comp %>%
  add_grammaticality_column(.) %>%
  convert_to_factor_columns(.) ->
  gpt_comp

```



```{r}
rubert_comp
```

## Adding RuBERT and GPT predicted number columns

We add columns that show RuBERT's preference of the correct number


```{r}
compute_deltas <- function(df, df_name){
  sing_col = as.symbol(str_glue("left_{df_name}_is_singular_score"))
  plur_col = as.symbol(str_glue("left_{df_name}_is_plural_score"))

  df %>% mutate(
    verb_correct_delta = case_when(
      N1 == "S" ~ !!sing_col - !!plur_col,
      N1 == "P" ~  !!plur_col - !!sing_col            # N1 == "P"
    ),
    verb_correct_delta2 = case_when(
      N1 == "S" ~ !!sing_col,
      N1 == "P" ~  !!plur_col,            # N1 == "P"
    )
  ) %>% mutate(
    is_correct = N1 == Pred,
    is_distr_different = N2 != N1,
    .after = Pred
  )
}

expand_scores <- function(df){
  df %>%
    # we delete dataset-level Pred because it will cause duplicates
    filter(Pred == "S") %>%
    pivot_longer(matches("left_.*_score"), names_to = "Pred2", values_to = "score")  %>%
    mutate(Pred2 = if_else(str_detect(Pred2, "singular"), "S", "P"))
}
```


```{r}
rubert_comp %>%
  compute_deltas(., "bert") ->
  rubert_comp

gpt_comp %>%
  compute_deltas(., "gpt") ->
  gpt_comp
```


These models only saw words before Pred (1 to 3), as such, actual Pred number of the sentences didn't influence them.
Thus scores of sentences N1=N2=X, Pred=P and N1=N2=X, Pred=S are exactly the same


```{r}
show_left_scores <- function(df, df_name){
  text_left_col = as.symbol(ifelse(df_name=="gpt", "left", "masked_left"))
  
  df %>%
    arrange(Sent, N1, N2, Pred) %>%
    select(N1, N2, Pred, Code, !!text_left_col, contains("left") & contains("score"))
}

```


```{r} 
rubert_comp %>%
  show_left_scores(., "bert")

```

```{r}
summarise_delta <- function(df){
  df %>%
    group_by(N1, N2, Pred) %>%
    summarise(
      across(verb_correct_delta,
             list(mean=mean, median=median)
      )
    )
}
```


```{r}
rubert_comp %>%
  summarise_delta()
```


```{r}
rubert_comp %>%
  ggplot(aes(x=Pred, y=verb_correct_delta, fill=Pred)) +
  geom_violin() +
  geom_boxplot(width=0.1, fill="white") +
  facet_wrap(N1 ~ N2, labeller = label_both)
```


Naturally, this is true for GPT too.

```{r}
gpt_comp %>%
    show_left_scores(., "gpt")
```

```{r}
gpt_comp %>%
  summarise_delta()

```

```{r}
gpt_comp %>%
  ggplot(aes(x=Pred, y=verb_correct_delta, fill=Pred)) +
  geom_violin() +
  geom_boxplot(width=0.1, fill="white") +
  facet_wrap(N1 ~ N2, labeller = label_both)
```



So, to avoid using duplicate data, we leave data for only one Pred (it doesn't matter which). 


```{r}
nrow(rubert_comp)

rubert_comp %>%
  filter(Pred == "S") -> 
  rubert_comp

nrow(rubert_comp)


rubert_comp %>%
  write_csv(., "rubert_delta_comp.csv")
```

```{r}
colnames(rubert_comp)
```

```{r}
nrow(gpt_comp)

gpt_comp %>%
  filter(Pred == "S") -> 
  gpt_comp

nrow(gpt_comp)


gpt_comp %>%
  write_csv(., "gpt_delta_comp.csv")
```

```{r}
colnames(gpt_comp)
```

## Stat Functions


```{r}
test_lmer_signif_KR <- function(model, x_vars, categorial=FALSE){
  res <- data.frame()
  
  print(model)
  for (var in x_vars){
    reduced_model = update(model, as.formula(paste("~ . -", var)))
    
    # print(var)
    # print(reduced_model)
    
    comp = KRmodcomp(model, reduced_model)
    # print(comp$test)

    var_df <- comp$test[1, c("stat", "ddf", "p.value")]
    var_df$mod_is_singular = isSingular(reduced_model)
    rownames(var_df) <- c(var)
    
    res <- rbind(res, var_df)
  }
  
  res %>%
    tibble::rownames_to_column(., "factor") %>%
    pivot_wider(
      names_from = factor, 
      values_from = !factor, 
      names_glue = "{factor}_KR_{.value}"
    )
}
```


## Reporting functions

### Functions to fetch the relevant part of the dataframe

```{r}

make_subj_col <- function(i){
  paste0("sh", i)
}

make_obj_col <- function(i){
  paste0("oh", i)
}

make_df_for_head <- function(df, head_i){
  # i = 5

  full_attention_cols = c("subj_attention", "obj_attention")
  
  subject_head_col = paste("sh", head_i, sep="")
  object_head_col = paste("oh", head_i, sep="")
  used_attention_cols = c(subject_head_col, object_head_col)
  
  return (df %>%
    select(
      !!used_attention_cols
      | (!starts_with("sh") & !starts_with("oh") & !(!!full_attention_cols))
    ))
}


make_meta_info <- function(i, model_name, ...){
  meta_info <- data.frame(i, model_name)
  names(meta_info) <- c("i", "model")
  
  meta_info
}


```


### Functions to fetch info

```{r}
lmer_model_info_to_df <- function(lmer_model, ...){
  call = as.character(lmer_model@call)
  call = paste0(call[1], "(", call[2], ", data=", call[3],  ")")
  
  optinfo = lmer_model@optinfo
  optimizer = optinfo$optimizer
  
  if (! ("messages" %in% names(optinfo$conv$lme4) )){
    optimizer_message = optinfo$message
  } else {
    optimizer_message = paste(optinfo$conv$lme4$messages, collapse = "; ")
  }
  
  n_observations = nobs(lmer_model)
  
  n_rand_effect_groups = ngrps(lmer_model)
  colnames(n_rand_effect_groups) <- rownames(n_rand_effect_groups)
  rownames(n_rand_effect_groups) <- NULL
  
  data.frame(cbind(
    call, n_observations, n_rand_effect_groups,
    optimizer, optimizer_message
  ))
}
```

```{r}
coeffs_from_summary_to_df <- function(
  model_summary, categorial=FALSE, ...
){
  model.coeffs = model_summary$coefficients
  df = data.frame(model.coeffs, check.names=FALSE)
  df = tibble::rownames_to_column(df, "factor")
  
  if (categorial){
    p_value_col = "Pr(>|z|)"
  } else {
    p_value_col = "Pr(>|t|)"
  }
  # print(c(categorial, p_value_col))
  
  df %>% mutate(
    factor = case_when(
        factor=="(Intercept)" ~ "Intercept",
        str_detect(factor, "^Y") ~ substr(factor, 1, 3),
        TRUE ~ factor
    )
  ) %>% rename(
    p.value = p_value_col,
    stdError = "Std. Error"
  ) -> df
  
  df %>% pivot_wider(
    names_from = factor, 
    values_from = !factor, 
    names_glue = "{factor}_{.value}"
  )
}
```


```{r}
extra_info_from_summary_to_df <- function(model_summary, ...){
  REML_df <- data.frame(model_summary$AICtab)
  colnames(REML_df) <- rownames(REML_df)
  rownames(REML_df) <- NULL
  
  loglik_df <- data.frame(model_summary$logLik)
  colnames(loglik_df) <- c("logLik")
  
  bind_cols(REML_df, loglik_df)
}

extra_info_from_summary_to_df_cat <- function(model_summary, ...){
  bind_rows(model_summary$AICtab)
}
```


```{r}
get_full_lmer_info <- function(model, model_summary, categorial=FALSE, ...){
  
  model.coeffs = coeffs_from_summary_to_df(model_summary, categorial=categorial, ...)
  model_info = lmer_model_info_to_df(model, ...)
  
  if (categorial){
    extra_fit_info = extra_info_from_summary_to_df_cat(model_summary, ...)  
  }
  else {
    extra_fit_info = extra_info_from_summary_to_df(model_summary, ...)  
  }
  
  # print(c(dim(model.coeffs), dim(model_info), dim(extra_fit_info)))
  
  bind_cols(model_info, extra_fit_info, model.coeffs)
}
```


## Model and human preference of the correct number

### Plots

```{r}
rubert_comp %>%
  # mutate(kind = factor(kind, levels=c("ungram", "distr", "gram"))) %>%
  group_by(N1, distr_like_pl) %>%
  summarise(across(verb_correct_delta, list(mean=mean, median=median, sd=sd)))
```



```{r}
rubert_comp %>%
  mutate(kind = factor(kind, levels=c("ungram", "distr", "gram"))) %>%
  group_by(kind) %>%
  summarise(across(verb_correct_delta, list(mean=mean, median=median, sd=sd)))
```

```{r}
rubert_comp %>%
  mutate(kind = factor(kind, levels=c("ungram", "distr", "gram"))) %>%
  ggplot(aes(x=kind, y=verb_correct_delta)) +
    geom_violin() +
    geom_boxplot(width=0.1, fill="white") +
    labs(title="RUBERT")
```


```{r}
gpt_comp %>%
  # mutate(kind = factor(kind, levels=c("ungram", "distr", "gram"))) %>%
  group_by(N1, distr_like_pl) %>%
  summarise(across(verb_correct_delta, list(mean=mean, median=median, sd=sd)))
```


```{r}
gpt_comp %>%
  mutate(kind = factor(kind, levels=c("ungram", "distr", "gram"))) %>%
  group_by(kind) %>%
  summarise(across(verb_correct_delta, list(mean=mean, median=median, sd=sd)))
```

```{r}
gpt_comp %>%
  mutate(kind = factor(kind, levels=c("ungram", "distr", "gram"))) %>%
  ggplot(aes(x=kind, y=verb_correct_delta)) +
    geom_violin() +
    geom_boxplot(width=0.1, fill="white")
```

### 3-valued kind calculation, distinct pred

```{r}
all_coeffs = tibble()

make_coeffs_table <- function(model_fit, model_name, data_subset){
  stopifnot(model_name %in% c("rubert", "rugpt", "humans"))
  stopifnot(data_subset %in% c("acc", "gen", "both"))
  
  cbind(list(model=model_name, data=data_subset),  tidy(model_fit, "fixed"))   
}
```


```{r}
rubert_comp
```

```{r}
make_kind2_scores <- function(df){
  df %>%
    expand_scores() %>%
    mutate(
      kind2=as.factor(case_when(
        N1 == Pred2 ~ "gram",
        (N1 != Pred2) & (N2 == Pred2) ~ "distr",
        TRUE ~ "ungram"
      )),
      .after=Pred2
    )
}
```

```{r}
rubert_comp %>%
  make_kind2_scores() ->
  rubert_comp_scores

rubert_comp_scores
```


```{r}
gpt_comp %>%
  make_kind2_scores() ->
  gpt_comp_scores

gpt_comp_scores
```


```{r}
mod5_rubert = lmer(score ~ N1 + N2 + kind2 + (1 | Sent), data=rubert_comp_scores)
summary(mod5_rubert)

mod5_rubert_coeffs = make_coeffs_table(mod5_rubert, "rubert", "both")
all_coeffs = rbind(all_coeffs, mod5_rubert_coeffs)

info5_rubert <- get_full_lmer_info(mod5_rubert, summary(mod5_rubert))

mod5KR_rubert <- test_lmer_signif_KR(mod5_rubert, c("N1", "N2", "kind2"))
mod5KR_rubert
```

```{r}
mod5_gpt = lmer(score ~ N1 + N2 + kind2 + (1 | Sent), data=gpt_comp_scores)
summary(mod5_gpt)

mod5_gpt_coeffs = make_coeffs_table(mod5_gpt, "rugpt", "both")
all_coeffs = rbind(all_coeffs, mod5_gpt_coeffs)

info5_gpt <- get_full_lmer_info(mod5_gpt, summary(mod5_gpt))

mod5KR_gpt <- test_lmer_signif_KR(mod5_gpt, c("N1", "N2", "kind2"))
mod5KR_gpt
```


#### by Group

```{r}
rubert_comp_scores %>% filter(Group == 1) -> rubert_comp_scores_acc

mod5_rubert_acc = lmer(score ~ N1 + N2 + kind2 + (1 | Sent), data=rubert_comp_scores_acc)
summary(mod5_rubert_acc)

mod5_rubert_acc_coeffs = make_coeffs_table(mod5_rubert_acc, "rubert", "acc")
all_coeffs = rbind(all_coeffs, mod5_rubert_acc_coeffs)

info5_rubert_acc <- get_full_lmer_info(mod5_rubert_acc, summary(mod5_rubert_acc))

mod5KR_rubert_acc <- test_lmer_signif_KR(mod5_rubert_acc, c("N1", "N2", "kind2"))
mod5KR_rubert_acc
```


```{r}
rubert_comp_scores %>%
  filter(Group == 2) ->
  rubert_comp_scores_gen

mod5_rubert_gen = lmer(score ~ N1 + N2 + kind2 + (1 | Sent), data=rubert_comp_scores_gen)
summary(mod5_rubert_gen)

mod5_rubert_gen_coeffs = make_coeffs_table(mod5_rubert_gen, "rubert", "gen")
all_coeffs = rbind(all_coeffs, mod5_rubert_gen_coeffs)

info5_rubert_gen <- get_full_lmer_info(mod5_rubert_gen, summary(mod5_rubert_gen))

mod5KR_rubert_gen <- test_lmer_signif_KR(mod5_rubert_gen, c("N1", "N2", "kind2"))
mod5KR_rubert_gen
```

Group 2 is genitive, which is syncretic like Nom.Pl = Gen.Sg (!= Acc.Pl)

```{r}
rubert_comp_scores %>%
  filter(Group == 2) %>%
  mutate(
    kind3=as.factor(case_when(
      N1 == Pred2 ~ "gram",
      (N1 != Pred2) & (N2 != Pred2) ~ "distr",
      TRUE ~ "ungram"
    )),
    .after=Pred2
  ) ->
  rubert_comp_scores_gen_syncr

mod5_rubert_gen_syncr = lmer(score ~ N1 + N2 + kind3 + (1 | Sent), data=rubert_comp_scores_gen_syncr)
summary(mod5_rubert_gen_syncr)

info5_rubert_gen_syncr <- get_full_lmer_info(mod5_rubert_gen_syncr, summary(mod5_rubert_gen_syncr))

mod5KR_rubert_gen_syncr <- test_lmer_signif_KR(mod5_rubert_gen_syncr, c("N1", "N2", "kind3"))
mod5KR_rubert_gen_syncr
```



```{r}
gpt_comp_scores %>%
  filter(Group==1) ->
  gpt_comp_scores_acc

mod5_gpt_acc = lmer(score ~ N1 + N2 + kind2 + (1 | Sent), data=gpt_comp_scores_acc)
summary(mod5_gpt_acc)

mod5_gpt_acc_coeffs = make_coeffs_table(mod5_gpt_acc, "rugpt", "acc")
all_coeffs = rbind(all_coeffs, mod5_gpt_acc_coeffs)

info5_gpt_acc <- get_full_lmer_info(mod5_gpt_acc, summary(mod5_gpt_acc))

mod5KR_gpt_acc <- test_lmer_signif_KR(mod5_gpt_acc, c("N1", "N2", "kind2"))
mod5KR_gpt_acc

```


```{r}
gpt_comp_scores %>%
  filter(Group==2) ->
  gpt_comp_scores_gen

mod5_gpt_gen = lmer(score ~ N1 + N2 + kind2 + (1 | Sent), data=gpt_comp_scores_gen)
summary(mod5_gpt_gen)

mod5_gpt_gen_coeffs = make_coeffs_table(mod5_gpt_gen, "rugpt", "gen")
all_coeffs = rbind(all_coeffs, mod5_gpt_gen_coeffs)

info5_gpt_gen <- get_full_lmer_info(mod5_gpt_gen, summary(mod5_gpt_gen))

mod5KR_gpt_gen <- test_lmer_signif_KR(mod5_gpt_gen, c("N1", "N2", "kind2"))
mod5KR_gpt_gen
```


### other model plots

```{r}
rubert_comp %>%
  group_by(N1, N2, Pred) %>%
  summarise(
    across(verb_correct_delta,
           list(mean=mean, median=median)
    )
  )
```


```{r}
rubert_comp %>%
  ggplot(aes(x=Pred, y=verb_correct_delta, fill=Pred)) +
  geom_violin() +
  geom_boxplot(width=0.1, fill="white") +
  facet_wrap(N1 ~ N2, labeller = label_both)
  
```

### accuracy

```{r}

rubert_comp %>%
  mutate(
    verb_correct = verb_correct_delta > 0,
    # particip_correct = particip_correct_delta > 0,
    # pred_correct = pred_correct_delta > 0
  ) %>%
  summarise(
    n_verb_correct = sum(verb_correct),
    n_verb_wrong = length(verb_correct) - sum(verb_correct),
    # n_particip_correct = sum(particip_correct),
    # n_particip_wrong = length(particip_correct) - sum(particip_correct),
    # n_pred_correct = sum(pred_correct),
    # n_pred_wrong = length(pred_correct) - sum(pred_correct)
  )

```


```{r}

rubert_comp %>%
  mutate(
    verb_correct = verb_correct_delta > 0,
  ) %>%
  group_by(Code) %>%
  summarise(
    n_verb_correct = sum(verb_correct),
    n_verb_wrong = length(verb_correct) - sum(verb_correct),
  )

```


```{r}
rubert_comp %>%
  mutate(verb_correct = verb_correct_delta > 0) %>%
  group_by(N1, N2) %>%
  summarise(ratio_correct = mean(verb_correct))
```


```{r}
gpt_comp %>%
  mutate(verb_correct = verb_correct_delta > 0) %>%
  group_by(N1, N2) %>%
  summarise(ratio_correct = mean(verb_correct))
```

#### Other regression models

```{r}
mod <- lmer(verb_correct_delta ~ N1 + N2 +  (1 | Sent), data=rubert_comp)
summary(mod)
```

```{r}
test_lmer_signif_KR(mod, c("N1", "N2"))
```


```{r}
rubert_comp %>% 
  filter(Group == 1) ->
  rubert_comp_acc

mod2 <- lmer(verb_correct_delta ~ N1 + N2 + Group + is_distr_different + (1 | Sent), data=rubert_comp)
summary(mod2)

info2 <- get_full_lmer_info(mod2, summary(mod2))

```

```{r}
mod2KR = test_lmer_signif_KR(mod2, c("N1", "N2", "is_distr_different"))
mod2KR
```

```{r}
cbind(info2, mod2KR) %>%
  write_csv("bert_lmer_results.csv")
```


```{r}
mod2_gpt = lmer(verb_correct_delta ~ N1 + N2 + is_distr_different + (1 | Sent), data=gpt_comp)
summary(mod2_gpt)

info2_gpt <- get_full_lmer_info(mod2_gpt, summary(mod2_gpt))

mod2KR_gpt <- test_lmer_signif_KR(mod2_gpt, c("N1", "N2", "is_distr_different"))
mod2KR_gpt
```

```{r}
cbind(info2_gpt, mod2KR_gpt) %>%
  write_csv("gpt_lmer_results.csv")
```



```{r}
mod3 <- lmer(verb_correct_delta ~ N1 * N2 +  (1 | Sent), data=rubert_comp)
summary(mod3)
```

```{r}
mod4 <- lmer(verb_correct_delta2 ~ N1 + N2 + is_distr_different + (1 | Sent), data=rubert_comp)
summary(mod4)
```



### Humans

```{r}
humans
```


```{r}
humans %>% pull(part) %>% unique() %>% length()
```


```{r}
humans_word4 = humans %>% filter(reg == 4)
humans_word4

humans_word5 = humans %>% filter(reg == 5)
humans_word5

```

There are 80 sentences in the experiment where response time was measured 

```{r}
humans %>% pull(sent) %>% unique()
```


```{r}
humans_word4 %>%
  filter(sent=="S1") %>%
  select(part, sent, subj, pred, rt) %>%
  arrange(part, sent,  subj, pred)
```



```{r}
humans_word4 %>%
  select(part, sent, subj, pred, rt) %>%
  # group_by(part, sent, subj) %>%
  arrange(part, sent,  subj) %>%
  pivot_wider(names_from = pred, values_from = rt)

```


```{r}
humans %>%
  separate_wider_delim(
      "subj", "-", names = c("N1", "N2")
  ) %>%
  mutate(is_distr_different = N2 != N1) %>%
  mutate(
    kind=as.factor(case_when(
      N1 == pred ~ "gram",
      (N1 != pred) & (N2 == pred) ~ "distr",
      TRUE ~ "ungram"
    )),
    is_correct = N1 == pred,
    is_distractor = N2 == pred,
    .after=pred
  ) -> humans

humans
```

The effect is visible on word 5

```{r}
humans %>%
  filter(reg == 5) %>%
  mutate(kind = factor(kind, levels=c("ungram", "distr", "gram"))) %>%
  group_by(kind) %>%
  summarise(mean=mean(rt, na.rm=TRUE), median=median(rt, na.rm=TRUE), sd=sd(rt, na.rm=TRUE))
```



```{r}
humans %>%
  filter(reg == 5) %>%
  mutate(kind = factor(kind, levels=c("ungram", "distr", "gram"))) %>%
  ggplot(aes(x=kind, y=rt)) +
    geom_violin() +
    geom_boxplot(width=0.1, fill="white")
    # facet_wrap(N1 ~ N2, labeller = label_both)
```


```{r}
humans_word5 = humans %>% filter(reg == 5)

# humans_word5_acc = humans_word5 %>% filter(group==1)
  
lmer(rt ~ N1 + N2 + kind + (1 | sent) + (1|part),
     data=humans_word5) ->
  mod5_humans

summary(mod5_humans)

mod5_humans_coeffs = make_coeffs_table(mod5_humans, "humans", "both")
all_coeffs = rbind(all_coeffs, mod5_humans_coeffs)

info5_humans <- get_full_lmer_info(mod5_humans, summary(mod5_humans))

mod5KR_humans <- test_lmer_signif_KR(mod5_humans, c("N1", "N2", "kind"))
mod5KR_humans
```


```{r}
humans_word5_acc = humans %>% filter(reg == 5) %>% filter(group == 1)

lmer(rt ~ N1 + N2 + kind + (1 | sent) + (1|part),
     data=humans_word5_acc) ->
  mod5_humans_acc

summary(mod5_humans_acc)

mod5_humans_acc_coeffs = make_coeffs_table(mod5_humans_acc, "humans", "acc")
all_coeffs = rbind(all_coeffs, mod5_humans_acc_coeffs)

info5_humans_acc <- get_full_lmer_info(mod5_humans_acc, summary(mod5_humans_acc))

mod5KR_humans_acc <- test_lmer_signif_KR(mod5_humans_acc, c("N1", "N2", "kind"))
mod5KR_humans_acc
```



```{r}
humans_word5_gen = humans %>% filter(reg == 5) %>% filter(group == 2)

# humans_word5_acc = humans_word5 %>% filter(group==1)
  
lmer(rt ~ N1 + N2 + kind + (1 | sent) + (1|part),
     data=humans_word5_gen) ->
  mod5_humans_gen

summary(mod5_humans_gen)

mod5_humans_gen_coeffs = make_coeffs_table(mod5_humans_gen, "humans", "gen")
all_coeffs = rbind(all_coeffs, mod5_humans_gen_coeffs)

info5_humans_gen <- get_full_lmer_info(mod5_humans_gen, summary(mod5_humans_gen))

mod5KR_humans_gen <- test_lmer_signif_KR(mod5_humans_gen, c("N1", "N2", "kind"))
mod5KR_humans_gen
```


There is no effect on word 4 however (these results are like Slioussar's)

```{r}
humans_word4 = humans %>% filter(reg == 4)

# humans_word5_acc = humans_word5 %>% filter(group==1)
  
lmer(rt ~ N1 + N2 + kind + (1 | sent) + (1|part),
     data=humans_word4) ->
  mod5_humans_word4

summary(mod5_humans_word4)

info5_humans_word4 <- get_full_lmer_info(mod5_humans_word4, summary(mod5_humans_word4))

mod5KR_humans_word4 <- test_lmer_signif_KR(mod5_humans_word4, c("N1", "N2", "kind"))
mod5KR_humans_word4
```


### models coefficients plot

```{r}
all_coeffs
```
```{r}
all_coeffs %>%
  count(model, data)

all_coeffs %>%
  count(term)

```

```{r}
all_coeffs %>%
  mutate(term = case_when(
    term == "kindungram" ~  "kind2ungram",
    term == "kindgram" ~  "kind2gram",
    TRUE ~ term,
  )) ->
  all_coeffs


all_coeffs %>%
  count(term)
```


```{r}

get_humans <- function(df){
  df %>% filter(model == "humans")
}

get_models <- function(df){
  df %>% filter(model != "humans")
}


round_any = function(x, accuracy, f=round){f(x/ accuracy) * accuracy}

find_offset <- function(variable, round_to=6){
  max_ = max(variable)
  min_ = min(variable)
  print(c(max_, min_))
  
  round_any((max_ + abs(min_) - 1), round_to, f=ceiling)
}

get_list_vals <- function(l){
  unname(unlist(l))
}

make_minor_breaks <- function(variable, offsets, step=0.5){
  max_ = ceiling(max(variable))
  print(max_)
  
  minor_breaks = c()
  for (offset in offsets){
    minor_breaks = c(minor_breaks, seq(offset - max_, offset + max_, step))
  }
  
  minor_breaks
}


make_coeffs_to_y_center <- function(df, coeffs_order, round_to=6){
  coeffs_y_step = find_offset(df$estimate, round_to = round_to)
  print(coeffs_y_step)
  
  coeffs_to_y_center = list()
  for (i in seq_along(coeffs_order)){
     coeffs_to_y_center = c(coeffs_to_y_center, (i - 1) * coeffs_y_step)
  }
  coeffs_to_y_center = setNames(coeffs_to_y_center, coeffs_order)
  coeffs_to_y_center
}

```

```{r}
scale_human_subset <- function(df, scale_factor){
  df %>%
    mutate(estimate = case_when(
      model == "humans" ~ estimate / scale_factor,
      TRUE ~ estimate
    ))
}
  
```


```{r}
all_coeffs
```

```{r}
all_coeffs %>%
  write_csv("regression_coefficients.csv")
```

```{r}
all_coeffs <- read_csv("regression_coefficients.csv")
all_coeffs
```



```{r}
alpha = 0.05

coeffs_order = c(
  "(Intercept)",
  "kind2ungram",
  "kind2gram",
  "N2S",
  "N1S"
)
final_names = c(
  "(Intercept)",
  "Kind=ungram-\nmatical_feats",
  "Kind=gram-\nmatical_feats",
  "Attractor\n Number = S",
  "Subject\n Number = S"
)
model_order = c("rubert", "rugpt", "humans")
coeffs_y_step = 6
y_limits = c(-3, 24)


all_coeffs_humans <- get_humans(all_coeffs)
all_coeffs_models <- get_models(all_coeffs)

scale_factor = round_any(max(all_coeffs_humans$estimate) / max(all_coeffs_models$estimate), 5)
all_coeffs_2 = scale_human_subset(all_coeffs, scale_factor)

coeffs_to_y_center = make_coeffs_to_y_center(all_coeffs_2, coeffs_order, round_to = coeffs_y_step)

get_y_center <- function(coeff){
  coeffs_to_y_center[[coeff]]
}

make_range <- function(df){
  df %>%
    mutate(
      is_significant = if_else(p.value < alpha, TRUE, FALSE),
      coeff_y = sapply(term, get_y_center),
      estimate2 = coeff_y + estimate,
      estimate_lower = pmin(estimate2, coeff_y),
      estimate_upper = pmax(estimate2, coeff_y),
      estimate_center = (estimate_lower + estimate_upper) / 2,
    )
}


all_coeffs_2 %>% 
  make_range() %>%
  mutate(
    is_significant=factor(is_significant, levels = c(TRUE, FALSE)),
    data=factor(data, levels = c("both", "acc", "gen")),
    model=factor(model, levels = model_order)
  ) ->
  all_coeffs_3

all_coeffs_3_humans = get_humans(all_coeffs_3)
all_coeffs_3_models = get_models(all_coeffs_3)
coeffs_to_y_center <- setNames(coeffs_to_y_center, final_names)

all_coeffs_3 %>%
  {
    ggplot(., aes(
      y=estimate_center, x=model, color=is_significant, linetype=is_significant)
    ) +
    geom_linerange(
      data = all_coeffs_3_models, 
      mapping = aes(y=estimate_center, ymin=estimate_lower, ymax=estimate_upper), linewidth=1.3
    ) +
    geom_linerange(
      data = all_coeffs_3_humans, 
      mapping = aes(
        y=estimate_center, ymin=estimate_lower, ymax=estimate_upper
      ), linewidth=1.3
    ) +
    geom_text(aes(label=round(estimate, 2)), vjust="outward", hjust=-0.2, size=3, fontface="bold") +
    # scale_y_continuous(name="estimate_center", sec.axis=sec_axis(name="humans estimate_center (s)")) +
    # scale_color_discrete("cvidis") +
    scale_color_viridis(discrete = TRUE, option="E", begin=0, end=0.8, direction = 1) +
    facet_wrap(~data, strip.position = "bottom") +
    theme(
      # plot.margin = margin(r = 15, l = 15, unit = "pt"),
      panel.background = element_rect(
        fill = "white", colour = "white", size = 0.5, linetype = "solid"
      ),
      panel.grid.major = element_line(size = 0.5, linetype = 'solid', colour = "lightgray"), 
      panel.grid.minor = element_line(size = 0.25, linetype = 'dotted', colour = "lightgray"),
      panel.spacing = unit(0, "lines"), 
      
      strip.background = element_blank(),
      strip.clip="off",
      strip.placement = "outside",
      strip.text = element_text(size = 12),
      
      # base_size=10,
      text=element_text(family="Times New Roman"),
      axis.text.x = element_text(angle = 20, hjust = 0.5, vjust = 0.8),
      axis.title.y = element_text(size=12),
      
      legend.position = "none",
    ) +
    scale_y_continuous(
      breaks = get_list_vals(coeffs_to_y_center), labels = names(coeffs_to_y_center),
      minor_breaks = make_minor_breaks(.$estimate, get_list_vals(coeffs_to_y_center)),
      sec.axis = dup_axis(name="humans' coefficients / 100 (ms)", labels=NULL)
    ) +
    scale_x_discrete(
      limits = model_order,
      expand = expansion(add = c(0.6, 0.6)),
      # guide = guide_axis(n.dodge = 2)
    ) +
    labs(x = NULL, y="models' coefficients (log-prob units)")
  } ->
  all_coeffs_plot

all_coeffs_plot
```

```{r}
cairo_pdf("regressions_coefficients_06.pdf", width=8, height=4)

all_coeffs_plot

dev.off()

```


```{r}
all_coeffs_3_models %>%
  mutate(model=as.character(model)) %>%
  {
    ggplot(., aes(y=estimate_center, x=model, color=is_significant, linetype=is_significant)) +
    geom_linerange(
      mapping = aes(y=estimate_center, ymin=estimate_lower, ymax=estimate_upper), linewidth=1.3
    ) +
    geom_text(aes(label=round(estimate, 2)), vjust="outward", hjust=-0.2, size=3, fontface="bold") +
    scale_color_viridis(discrete = TRUE, option="E", begin=0, end=0.8, direction = 1) +
    facet_wrap(~data, strip.position = "bottom") +
    theme(
      # plot.margin = margin(r = 15, l = 15, unit = "pt"),
      panel.background = element_rect(
        fill = "white", colour = "white", size = 0.5, linetype = "solid"
      ),
      panel.grid.major = element_line(size = 0.5, linetype = 'solid', colour = "lightgray"), 
      panel.grid.minor = element_line(size = 0.25, linetype = 'dotted', colour = "lightgray"),
      panel.spacing = unit(0, "lines"), 
      
      strip.background = element_blank(),
      strip.clip="off",
      strip.placement = "outside",
      strip.text = element_text(size = 12),
      
      # base_size=10,
      text=element_text(family="Times New Roman"),
      # axis.text.x = element_text(angle = 20, hjust = 0.5, vjust = 0.8),
      axis.title.y = element_text(size=12),
      
      legend.position = "none",
    ) +
    ylim(-6, 27) +
    scale_y_continuous(
      breaks = get_list_vals(coeffs_to_y_center), labels = names(coeffs_to_y_center),
      minor_breaks = make_minor_breaks(.$estimate, get_list_vals(coeffs_to_y_center)),
      # sec.axis = dup_axis(name="humans' coefficients / 100 (ms)", labels=NULL)
      limits = y_limits
    ) +
    scale_x_discrete(
      limits = c("rubert", "rugpt"),
      # expand = expansion(add = c(0.3, 0.3)),
      # guide = guide_axis(n.dodge = 2)
    ) +
    labs(x = NULL, y="models' coefficients (log-prob units)")
  } ->
  all_coeffs_models_plot

all_coeffs_models_plot
```

```{r}
cairo_pdf("regressions_coefficients_07_models.pdf", width=6, height=4)

all_coeffs_models_plot

dev.off()
```

```{r}
all_coeffs_3_humans %>%
  mutate(model=as.character(model)) %>%
  {
    ggplot(., aes(y=estimate_center, x=model, color=is_significant, linetype=is_significant)) +
    geom_linerange(
      mapping = aes(y=estimate_center, ymin=estimate_lower, ymax=estimate_upper), linewidth=1.3
    ) +
    geom_text(aes(label=round(estimate, 2)), vjust="outward", hjust=-0.2, size=3, fontface="bold") +
    scale_color_viridis(discrete = TRUE, option="E", begin=0, end=0.8, direction = 1) +
    facet_wrap(~data, strip.position = "bottom") +
    theme(
      # plot.margin = margin(r = 15, l = 15, unit = "pt"),
      panel.background = element_rect(
        fill = "white", colour = "white", size = 0.5, linetype = "solid"
      ),
      panel.grid.major = element_line(size = 0.5, linetype = 'solid', colour = "lightgray"), 
      panel.grid.minor = element_line(size = 0.25, linetype = 'dotted', colour = "lightgray"),
      panel.spacing = unit(0, "lines"), 
      
      strip.background = element_blank(),
      strip.clip="off",
      strip.placement = "outside",
      strip.text = element_text(size = 12),
      
      text=element_text(family="Times New Roman"),
      # axis.text.x = element_text(size=12),
      axis.title.y = element_text(size=12),
      
      legend.position = "none",
    ) +
    scale_y_continuous(
      breaks = get_list_vals(coeffs_to_y_center),
      # labels = names(coeffs_to_y_center),
      labels = NULL,
      minor_breaks = make_minor_breaks(.$estimate, get_list_vals(coeffs_to_y_center)),
      sec.axis = dup_axis(name="humans' coefficients / 100 (ms)", labels=NULL),
      limits = y_limits
    ) +
    scale_x_discrete(
      # limits = c("rubert", "rugpt"),
      # expand = expansion(add = c(0.3, 0.3)),
      # guide = guide_axis(n.dodge = 2)
    ) +
    labs(x = NULL, y=NULL)
  } ->
  all_coeffs_humans_plot

all_coeffs_humans_plot
```

```{r}
cairo_pdf("regressions_coefficients_06_humans.pdf", width=3, height=4)

all_coeffs_humans_plot

dev.off()
```